// Code generated by MockGen. DO NOT EDIT.
// Source: leap_join_test.go
//
// Generated by this command:
//
//	mockgen -source=leap_join_test.go -destination=leap_join_test_mock.go -package=topicsdb
//

// Package topicsdb is a generated GoMock package.
package topicsdb

import (
	reflect "reflect"

	kvdb "github.com/Fantom-foundation/lachesis-base/kvdb"
	gomock "go.uber.org/mock/gomock"
)

// Mock_table is a mock of _table interface.
type Mock_table struct {
	ctrl     *gomock.Controller
	recorder *Mock_tableMockRecorder
	isgomock struct{}
}

// Mock_tableMockRecorder is the mock recorder for Mock_table.
type Mock_tableMockRecorder struct {
	mock *Mock_table
}

// NewMock_table creates a new mock instance.
func NewMock_table(ctrl *gomock.Controller) *Mock_table {
	mock := &Mock_table{ctrl: ctrl}
	mock.recorder = &Mock_tableMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mock_table) EXPECT() *Mock_tableMockRecorder {
	return m.recorder
}

// NewIterator mocks base method.
func (m *Mock_table) NewIterator(prefix, start []byte) kvdb.Iterator {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewIterator", prefix, start)
	ret0, _ := ret[0].(kvdb.Iterator)
	return ret0
}

// NewIterator indicates an expected call of NewIterator.
func (mr *Mock_tableMockRecorder) NewIterator(prefix, start any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewIterator", reflect.TypeOf((*Mock_table)(nil).NewIterator), prefix, start)
}

// Mock_iterator is a mock of _iterator interface.
type Mock_iterator struct {
	ctrl     *gomock.Controller
	recorder *Mock_iteratorMockRecorder
	isgomock struct{}
}

// Mock_iteratorMockRecorder is the mock recorder for Mock_iterator.
type Mock_iteratorMockRecorder struct {
	mock *Mock_iterator
}

// NewMock_iterator creates a new mock instance.
func NewMock_iterator(ctrl *gomock.Controller) *Mock_iterator {
	mock := &Mock_iterator{ctrl: ctrl}
	mock.recorder = &Mock_iteratorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mock_iterator) EXPECT() *Mock_iteratorMockRecorder {
	return m.recorder
}

// Error mocks base method.
func (m *Mock_iterator) Error() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Error")
	ret0, _ := ret[0].(error)
	return ret0
}

// Error indicates an expected call of Error.
func (mr *Mock_iteratorMockRecorder) Error() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Error", reflect.TypeOf((*Mock_iterator)(nil).Error))
}

// Key mocks base method.
func (m *Mock_iterator) Key() []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Key")
	ret0, _ := ret[0].([]byte)
	return ret0
}

// Key indicates an expected call of Key.
func (mr *Mock_iteratorMockRecorder) Key() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Key", reflect.TypeOf((*Mock_iterator)(nil).Key))
}

// Next mocks base method.
func (m *Mock_iterator) Next() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Next")
	ret0, _ := ret[0].(bool)
	return ret0
}

// Next indicates an expected call of Next.
func (mr *Mock_iteratorMockRecorder) Next() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Next", reflect.TypeOf((*Mock_iterator)(nil).Next))
}

// Release mocks base method.
func (m *Mock_iterator) Release() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Release")
}

// Release indicates an expected call of Release.
func (mr *Mock_iteratorMockRecorder) Release() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Release", reflect.TypeOf((*Mock_iterator)(nil).Release))
}

// Value mocks base method.
func (m *Mock_iterator) Value() []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Value")
	ret0, _ := ret[0].([]byte)
	return ret0
}

// Value indicates an expected call of Value.
func (mr *Mock_iteratorMockRecorder) Value() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Value", reflect.TypeOf((*Mock_iterator)(nil).Value))
}

// Mock_reader is a mock of _reader interface.
type Mock_reader struct {
	ctrl     *gomock.Controller
	recorder *Mock_readerMockRecorder
	isgomock struct{}
}

// Mock_readerMockRecorder is the mock recorder for Mock_reader.
type Mock_readerMockRecorder struct {
	mock *Mock_reader
}

// NewMock_reader creates a new mock instance.
func NewMock_reader(ctrl *gomock.Controller) *Mock_reader {
	mock := &Mock_reader{ctrl: ctrl}
	mock.recorder = &Mock_readerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mock_reader) EXPECT() *Mock_readerMockRecorder {
	return m.recorder
}

// Get mocks base method.
func (m *Mock_reader) Get(key []byte) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", key)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *Mock_readerMockRecorder) Get(key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*Mock_reader)(nil).Get), key)
}

// Has mocks base method.
func (m *Mock_reader) Has(key []byte) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Has", key)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Has indicates an expected call of Has.
func (mr *Mock_readerMockRecorder) Has(key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Has", reflect.TypeOf((*Mock_reader)(nil).Has), key)
}
