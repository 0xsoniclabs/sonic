// prevrandao package provides the functionality
// to generate the prevrandao value for the sonic consensus
// protocol.
package randao

import (
	"crypto/sha256"
	"math/big"

	"github.com/0xsoniclabs/sonic/inter/validatorpk"
	"github.com/0xsoniclabs/sonic/valkeystore"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/crypto"
)

// RandaoReveal is an opaque object that can be used by peers to generate
// the same randao value.
// RandaoReveal is generated by one node (proposer), the generation algorithm
// can then be reproduced by other nodes, verifying it.
type RandaoReveal []byte

// NewRandaoReveal Constructs a new RandaoReveal
//   - previousRandAo is the previous randao value
//   - replayProtection is value known to all peers and deterministically attributed
//     the current randao generation.
//   - proposerKey is the public key of the proposer originating this randao value
//   - Signer is the signer used to sign messages within the gossip package
func NewRandaoReveal(
	previousRandAo common.Hash,
	replayProtection *big.Int,
	proposerKey validatorpk.PubKey,
	Signer valkeystore.SignerI,
) (RandaoReveal, error) {

	hasher := sha256.New()
	hasher.Write(previousRandAo[:])
	hasher.Write(replayProtection.Bytes())
	hash := hasher.Sum(nil)

	return Signer.Sign(proposerKey, hash)
}

// GetRandAo verifies randaoSource payload and generates a new randao value.
// If the verification can be proven, this value is equal on all peers.
//   - previousRandAo is the previous randao value
//   - replayProtection is value known to all peers and deterministically attributed
//     the current randao generation. This value must be the same as the one used
//     to generate the RandaoSource. Therefore known by all peers.
//   - proposerKey is the public key of the proposer originating this randao value
func (s RandaoReveal) GetRandAo(
	previousRandAo common.Hash,
	replayProtection *big.Int,
	proposerPublicKey validatorpk.PubKey,
) (common.Hash, bool) {

	hasher := sha256.New()
	hasher.Write(previousRandAo[:])
	hasher.Write(replayProtection.Bytes())
	hash := hasher.Sum(nil)

	// if the signature does not correspond to the input data (hash, replayProtection)
	// for the given proposerPublicKey, then randao cannot be generated.
	if ok := crypto.VerifySignature(proposerPublicKey.Raw, hash, s); !ok {
		return common.Hash{}, false
	}

	tmp := [32]byte{}
	copy(tmp[:], s)
	return xorBytes32(previousRandAo, tmp), true
}

func xorBytes32(a, b [32]byte) (dst [32]byte) {
	for i := 0; i < 32; i++ {
		dst[i] = a[i] ^ b[i]
	}
	return
}
