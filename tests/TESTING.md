# Sonic Integration Testing

This document is designed to help newcomers navigate our integration testing framework. This guide provides an introduction to the framework's core concepts, what kind of test can be written, how to compose them and use helper utilities to write clean and efficient tests.


## Key Concepts

Our integration tests simulate a running network with one or many validator nodes, aimed to verify end-to-end properties of the network. Before diving into the details, it's helpful to understand the primary building blocks of our testing infrastructure.

- `Network`: The main object representing a (possibly multi-node) network. It is a self-contained environment that can be started and stopped for a single test. Its life cycle is usually managed by the test where it is created.
- `Session`: Provides an exclusive address space context within a `Network`. It has a dedicated account and a safe environment for sending transactions in parallel. While a `Network` can be shared among tests, a `Session` is designed to be used by a single test or sub-test to avoid resource collisions.
- `Account`: Is a pair of `common.Address` with an associated private key. They are created and funded by the `Sponsor` of the network to be used in test transactions. Usually used as origin/destination for a transaction.
- `Sponsor`: Is a special account with a significant balance that funds and signs transactions. Both `Network` and `Session` have a sponsor account that is used to send transactions.
- `Transactions`: They are the messages via which users can interact with the network. `Transactions` can be hand crafted or generated by custom `Contracts`.
- `Contracts` can be generated from solidity code (for examples look into [`sonic/tests/contracts`](https://github.com/0xsoniclabs/sonic/tree/main/tests/contracts)). A solidity file and `gen.go` file are needed for the generation.

## Getting Started

Here are some considerations to keep in mind when adding new integration tests:
1) If there is already an integration test file with the same domain, consider adding your test there before creating a new file.
0) If your test needs to do one of the following actions:
	- The network needs to be restarted
	- The network rules need to be updated
	- The networks epoch needs to be forcibly advanced.
	
	Then use an exclusive new network `net := StartIntegrationTestNet(t)`.
	For example:
	```Go
	import (
		"testing"
		"github.com/0xsoniclabs/sonic/tests"
		"github.com/stretchr/testify/require"
	)

	func TestNetworkRule_Update(t *testing.T){

		require := require.New(t)
		net := tests.StartIntegrationTestNet(t)

		current := tests.GetNetworkRules(t, net)
		modified := myRuleModifications(current)
		tests.UpdateNetworkRules(t, net, modified)
		AdvanceEpochAndWaitForBlocks(t, net)

		net.Restart()
		newConfig := tests.GetNetworkRules(t, net)
		require.Equal(modified, newConfig)
	}	
	```

	Otherwise we highly encourage you to use `session := getIntegrationTestNetSession(t, Upgrade)`

	```Go
	func TestMultipleSessions_CanSendLegacyTransactionsInBulk(t *testing.T) {
		session := getIntegrationTestNetSession(t, opera.GetSonicUpgrades())

		chainId := session.GetChainId()
		txs := types.Transaction[]{}
		for i := range 5 {
			tx := SetTransactionDefaults(t, session, &types.LegacyTx{}, session.GetSessionSponsor())
			signedTx := SignTransaction(t, chainId, tx, session.GetSessionSponsor())
			txs = append(txs, tx)
		}
		receipts, err := net.RunAll(txs)
		require.NoError(t, err, "failed to send transaction")
		require.Equal(t, len(receipts), len(txs))
	}
	```


0) If multiple properties or values need to be verified, analyze if it is possible to split them into sub cases using `t.Run` and even more, if each sub test can be parallelized with `t.Parallel()`. Keep in mind running tests in parallel might require you to use a `Session`.

	```Go
	func TestType_ManyProperties(t *testing.T){
		session := getIntegrationTestNetSession(t, opera.GetSonicUpgrades())

		t.Run("someProperty", func (t *testing.T){
			subSession := session.SpawnSession(t)
			t.Parallel()

			validateSomeProperty(t, session)
		})
		t.Run("anotherProperty", func (t *testing.T){
			subSession := session.SpawnSession(t)
			t.Parallel()

			validateAnotherProperty(t, session)
		})
	}
	```
	Note that `t.Parallel()` is always called after `SpawnSession`, that is to prevent concurrency issues. 

0) If all the tests in the new file take over 2 minutes consider moving it to its own sub-package so that go can automatically choose to run it in parallel with tests from other packages. 

## Framework Scope
The current implementation enables one to make test that:
- Send transactions and verify their effect on the blockchain.
- Simulate and query networks with multiple nodes.
- Modify a running network (such as changing rules, configs or advancing epochs)
- Deploy custom contracts and interact with them.
- Different network configurations or hard forks can be successfully deployed.

## Client

The network can produce `Client`s connected to the different nodes. These need to be closed and they can be used to interact with the JSON-RPC API.

```Go
func TestSendTransaction_InParallel(t *testing.T){
	session := getIntegrationTestNetSession(t, opera.GetSonicUpgrades())
	chainId := session.GetChainId()

	hashes := hash[]
	for i := range 5 {
		t.Run(fmt.Sprintf("parallel-%d", i), func(t *testing.T) {
			session := session.SpawnSession(t)
			t.Parallel()

			tx := SetTransactionDefaults(t, session, &types.LegacyTx{}, session.GetSessionSponsor())
			signedTx := SignTransaction(t, chainId, tx, session.GetSessionSponsor())
			err := client.SendTransaction(t.Context(), signedTx)
			require.NoError(t, err, "failed to send transaction")
			hash = append(hash, tx.Hash())
		})
	}
	receipts, err := net.GetReceipts(hashes)
	require.NoError(t, err)
	require.Equal(t, len(receipts), len(hashes))
}

```

Note transactions can be sent via `net.RunAll` which wait until it gets the receipts for all the transactions or with `client.SendTransaction` which does not wait for the transactions to be executed, hence enabling to send transactions asynchronously.

## Solidty Contracts

Solidy code can be hand crafted and then used to generate the corresponding Go code. For examples on this please look at `sonic/tests/contracts/counter/`, one must write the `.sol` file, such as
```Solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract Counter {
    int private count = 0;

    function incrementCounter() public {
        count += 1;
    }
}
```


and `gen.go` to generate the corresponding `counter.go`. Then it can be used as shown in `sonic/tests/counter_test.go`

```Go
func TestCounter_CanIncrementAndReadCounterFromHead(t *testing.T) {

	session := getIntegrationTestNetSession(t, opera.GetSonicUpgrades())
	t.Parallel()

	// Deploy the counter contract.
	contract, receipt, err := DeployContract(session, counter.DeployCounter)
	require.NoError(t, err, "failed to deploy contract; %v", err)
	require.Equal(t, receipt.Status, types.ReceiptStatusSuccessful)

	// Increment the counter a few times and check that the value is as expected.
	for i := 0; i < 10; i++ {
		counter, err := contract.GetCount(nil)
		require.NoError(t, err, "failed to get counter value")
		require.Equal(t, int64(i), counter.Int64(), "unexpected counter value")

		_, err = session.Apply(contract.IncrementCounter)
		require.NoError(t, err, "failed to apply increment counter contract")
	}
}
```


## Memory Analysis 

There is an optional tool to get heap memory reports per test, it was added in [PR#350](https://github.com/0xsoniclabs/sonic/pull/350)

## Require

Please use [testify/require]((https://github.com/stretchr/testify/blob/master/require/doc.go) ) for improved readability.