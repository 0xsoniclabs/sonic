package version

import (
	"fmt"
	"regexp"
)

var (
	// The version under development. It is used when the version is not
	// set by the Makefile.
	versionMajor = 2
	versionMinor = 1
)

// Get returns the complete version information.
func Get() Version {
	return _version
}

// String returns the version string.
func String() string {
	return Get().String()
}

// StringWithCommit returns the version string with the commit hash and date.
func StringWithCommit() string {
	vsn := Get().String()
	if len(gitCommit) >= 8 {
		vsn += "-" + gitCommit[:8]
	}
	if gitDate != "" {
		vsn += "-" + gitDate
	}
	return vsn
}

// GitCommit returns the commit hash if available. If not, the empty string
// is returned.
func GitCommit() string {
	return gitCommit
}

// GitDate returns the commit date if available. If not, the empty string
// is returned.
func GitDate() string {
	return gitDate
}

// Version represents a version of the code.
type Version struct {
	Major int
	Minor int
	Patch int
	Meta  string
	Dirty bool
}

// IsRelease returns true if the version is a release version. It returns false
// if the version has a meta string or is dirty.
func (v Version) IsRelease() bool {
	return v.Meta == "" && !v.Dirty
}

func (v Version) String() string {
	res := fmt.Sprintf("v%d.%d.%d", v.Major, v.Minor, v.Patch)
	if v.Meta != "" {
		res += "-" + v.Meta
	}
	if v.Dirty {
		res += "-dirty"
	}
	return res
}

var _version Version

func init() {
	version, err := parseVersion(codeVersion)
	if err != nil {
		panic("failed to parse version: " + err.Error())
	}
	_version = version
}

// parseVersion parses the GitTag into a version struct. This function may panic and must
// only be called during initialization or testing.
func parseVersion(gitTag string) (Version, error) {
	// If the tag is empty, the binary was not build using the Makefile or the
	// Makefile could not find git information. In this case, we return the
	// version under development.
	if gitTag == "" || gitTag == "::" {
		// Return the version under development.
		return Version{
			Major: versionMajor,
			Minor: versionMinor,
			Meta:  "dev",
		}, nil
	}

	// Check the format and decompose the git tag.
	// The accepted format is: v1.2.3(-meta):(dev):(dirty)
	pattern := regexp.MustCompile(`^(v\d+\.\d+\.\d+)(?:-((?:[a-zA-Z0-9-]+)*))?:(dev)?:(dirty)?$`)
	parts := pattern.FindStringSubmatch(gitTag)
	if len(parts) != 5 { // part 0 is the full match
		return Version{}, fmt.Errorf("failed to parse version string %q", gitTag)
	}

	// Parse the version string
	version := Version{}
	if _, err := fmt.Sscanf(parts[1], "v%d.%d.%d", &version.Major, &version.Minor, &version.Patch); err != nil {
		return version, fmt.Errorf("failed to parse version: %w", err)
	}

	// Parse the meta string
	version.Meta = parts[2]

	// If it is a dev version, increment the minor version and
	// set the meta string to include "dev".
	if len(parts[3]) > 0 {
		version.Minor++
		version.Patch = 0
		version.Meta = "dev"
	} else {
		// the dirty flag is only relevant for non-dev versions
		version.Dirty = len(parts[4]) > 0
	}

	return version, nil
}

// -- set by linker flags --------------------------------------------

var (

	// codeVersion is the full version string, generated by the Makefile.
	// This string is only set if the binary was built with the Makefile.
	codeVersion = ""

	// gitCommit is the commit hash, set by the Makefile.
	gitCommit = ""

	// gitDate is the commit date, set by the Makefile.
	gitDate = ""
)
